# Node.js

## 1.node的机制

**单线程**：在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程，而每个线程需要耗费大约2MB内存，理论上一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。Node.js不为每个客户连接创建一个新的线程，而仅仅使用**一个线程**。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。另外，单线程的带来的好处，还有操作系统完全不再有线程创建、销毁的时间开销。

**非阻塞I/O**：因为CPU的效率是远远高于I/O设备的执行效率的，如果让CPU去等待I/O的执行，将会极大地浪费时间，降低性能，比如在访问数据库或者读文件的时候，在传统的单线程处理机制中，在执行了访问数据库或文件代码之后，整个线程都将暂停下来（**阻塞I/O**），等待数据库或者文件系统返回结果才能执行后面的代码。I/O阻塞了代码的执行极大地降低了程序的执行效率。由于Node.js中采用了**非阻塞型I/O**机制，因此在执行了访问数据库或文件的代码之后，将立即转而执行其他代码，把返回结果的处理代码放在**回调函数**中，从而提高了程序的执行效率。当某个I/O执行完毕时，将以**事件**的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲理的解决方案：与其人多，但是好多人闲着；还不如一个人玩命，往死里干活儿。

**事件驱动**：在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在Node中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。**Node.js底层是C++（V8也是C++写的），**底层代码中，近半数都用于事件队列、回调函数队列的构建。

## 2.模块化

需要用到什么模块就用require引用什么模块

#### process进程模块

process模块允许你获得或者修改当前node进程的设置，不想其他的模块，**process是一个全局进程(node主进程)**，你可以直接通过process变量直接访问它。

node提供了一些process的属性，如下：

process.version：包含当前node实例的版本号；

process.installPrefix：包含安装路径；

process.platform：列举node运行的操作系统的环境，只会显示内核相关的信息，如：linux2， darwin，而不是“Redhat ES3” ，“Windows 7”，“OSX 10.7”等；

process.uptime()：包含当前进程运行的时长（秒）；

process.getgid(), process.setgid()：获取或者设置group id；

process.getuid(), process.setuid()：获取或者设计user id；

process.pid：获取进程id；

process.title：设置进程名称；

process.execPath：当前node进程的执行路径，如：/usr/local/bin/node；

process.cwd()：当前工作目录；

process.memoryUsage()：node进程内存的使用情况，rss代表ram的使用情况，vsize代表总内存的使用大小，包括ram和swap；

process.heapTotal,process.heapUsed：分别代表v8引擎内存分配和正在使用的大小。

process.nextTick()方法，允许你访问事件循环和延时那你的工作。

